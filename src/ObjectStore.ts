import type { RequestHandlerInterface, Transferable } from "./Interfaces.js";
import type {
  ErrorDescription,
  ExtendableRemotePath,
  ExtendingRemotePath,
  FunctionDescription,
  GcId,
  GcIdDescription,
  GcObjectDescription,
  GcObjectsDescription,
  Key,
  KeyDescription,
  LocalGcId,
  LocalizedGcId,
  MayHaveSymbol,
  NullDescription,
  ObjectDescription,
  ObjectStoreOptions,
  OwnKeyDescription,
  RemoteDescription,
  RemoteGcId,
  RemoteObject,
  RemoteObjectAble,
  RemotePath,
  ResolvedFunctionDescription,
  ResolvedObjectDescription,
  ResponseValueDescription,
  RootPathSegment,
  SymbolDescription,
  UndefinedDescription,
  ValueDescription,
  ValueRequestDescription,
  ValueResponseDescription,
  ValueSegment
} from "./types.js";

/**
 * Class to handle object Caching and Translation of ObjectDescriptions to RemoteObjects.
 * @public
 */
export class ObjectStore {
  /**
   * The interface to the RequestHandler Instance.
   */
  #requestHandler: RequestHandlerInterface;
  /**
   * Remembers if this instance is closed.
   */
  #closed: boolean = false;
  /**
   * The Options to use with this Instance.
   */
  #options: Required<ObjectStoreOptions>;
  /**
   * The Symbol this Instance uses to Access the Proxy Data.
   */
  #symbolProxyData: symbol = Symbol();
  /**
   * Last id wich was generated, used to generate the next id.
   */
  #lastId: number = 0;
  /**
   * List of all Objects and Symbols wich where send to the Remote to.
   * Is mapping from an Value to its description.
   */
  #descFromLocalValue: WeakMap<object | symbol, GcIdDescription> = new WeakMap();
  /**
   * List of all the GcIds which where sent to the Remote.
   * Is mapping from an local ID to its description.
   */
  #descFromLocalId: Map<GcId, GcIdDescription> = new Map();
  /**
   * Keeps track of the newly generated GcIds and when this happened.
   */
  #newLocalIds: Map<number, number> = new Map();
  /**
   * List of all Objects (Symbol | {}) wich where received by the Remote with a number id.
   * Is Mapping from an Remote Id to a WeakReference of Promise of the Value.
   * We want the value to get be Garbage Collected, if no longer used.
   */
  #valueFromRemoteNumberId: Map<number, WeakRef<Promise<object | symbol>>> = new Map();
  /**
   * List of all Objects (Symbol | {}) wich where received by the Remote with a string id.
   * Is Mapping from an Remote Id to a Promise of the Value.
   * String Ids should be held on to, because these are manually generated by library user.
   */
  #valueFromRemoteStringId: Map<string, Promise<object | symbol>> = new Map();
  /**
   * Keeps track of all remote ids wich values where Garbage Collected.
   */
  #deletedRemoteIds: Set<number> = new Set();
  /**
   * List of all the Symbols received from Remote to their id.
   * Needed to translate it back to the Original id on the Remote side.
   */
  #remoteSymbolIds: WeakMap<symbol, GcId> = new WeakMap();
  /**
   * Used for registering all values, wich might be garbage Collected.
   * Will call a Callback to do cleanup.
   */
  #finalizationReg: FinalizationRegistry<number>;

  /**
   * Creates a new ObjectStore.
   * @param requestHandler - Interface describing a RequestHandler.
   * @param options - Options on how the ObjectStore should operate (options should be the same for remote).
   */
  constructor(requestHandler: RequestHandlerInterface, options: ObjectStoreOptions = {}) {
    this.#options = {
      remoteObjectPrototype: "full",
      remoteError: "newError",
      noToString: false,
      ...options
    };
    this.#requestHandler = requestHandler;
    this.requestHandler = this.requestHandler.bind(this);
    if (requestHandler.setRequestHandler) requestHandler.setRequestHandler(this.requestHandler);
    this.disconnectedHandler = this.disconnectedHandler.bind(this);
    if (requestHandler.setDisconnectedHandler) requestHandler.setDisconnectedHandler(this.disconnectedHandler);
    this.#finalizationReg = new FinalizationRegistry((id) => this.#cleanupObject(id));
  }

  /**
   * Stores a object or function to be used by the remote.
   * @param id - a string with wich the remote can request this object.
   * @param object - Object or function to share with remote.
   * @public
   */
  exposeRemoteObject(id: string, value: RemoteObjectAble): void {
    this.#checkClosed();
    if (this.#descFromLocalId.has(id)) throw new Error(`Remote Object with id ${id} is already exposed.`);
    if (this.#descFromLocalValue.has(value)) throw new Error(`Remote Object is already exposed as ${this.#descFromLocalValue.get(value)?.id}.`);
    const time = performance.now();
    const description = { id, time, value };
    this.#descFromLocalValue.set(value, description);
    this.#descFromLocalId.set(id, description);
  }

  /**
   * Will get the description of an Object from Remote and returns a local Proxy wich represents this Object.
   * Will request the metadata of the object from remote the first time for every id.
   * Use this method if you need to use 'key in object', 'object instanceof class', 'Object.keys(object)' or similar.
   * Use getRemoteProxy if you don't need to use these operations because it does not need to request data from remote.
   * @param id - id of the object or function to request.
   * @returns a Promise resolving to a Proxy wich represents this object.
   * @public
   */
  async requestRemoteObject<const T extends RemoteObjectAble>(id: string): Promise<RemoteObject<T>> {
    this.#checkClosed();
    return <RemoteObject<T>>await this.#requestValue({ type: "root", id });
  };

  /**
   * Will return a local Proxy wich represents this Object.
   * This does not Request any data from remote.
   * This will initially succeed, even if the id is not exposed on remote (will only fail on the first request to remote).
   * Use getRemoteObject if you need to use 'key in object', 'object instanceof class', 'Object.keys(object)' or similar.
   * @param id - id of the object or function to request.
   * @returns a Proxy wich represents this object.
   * @public
   */
  getRemoteObject<const T extends RemoteObjectAble>(id: string): RemoteObject<T> {
    this.#checkClosed();
    return <RemoteObject<T>>this.#createRemoteProxy({ type: "root", id, });
  }

  /**
   * This function should be called for every Message received from remote.
   * This will call the newMessageHandler on the RequestHandler if defined.
   * @param data - the data wich was received from remote.
   * @public
   */
  newMessage(data: Transferable): void {
    if (!this.#requestHandler.newMessageHandler) throw new Error("Function is not Implemented by requestHandler");
    return this.#requestHandler.newMessageHandler(data);
  };

  /**
   * This function should be called if the connection to the remote is lost (for cleanup).
   */
  disconnectedHandler(): void {
    this.close();
  };

  /**
   * Call this to Close the Connection.
   * Also Calls to the disconnectHandler on the RequestHandler.
   */
  close(): void {
    if (this.#closed) return;
    this.#closed = true;
    this.#requestHandler.request({ type: "close" }).catch(() => { });
    this.#deletedRemoteIds.clear();
    this.#valueFromRemoteStringId.clear();
    this.#valueFromRemoteNumberId.clear();
    this.#newLocalIds.clear();
    this.#descFromLocalId.clear();
    if (this.#requestHandler.disconnectedHandler) this.#requestHandler.disconnectedHandler();
  };

  /**
   * This function should be invoked for every request to the Remote.
   * It needs to be called with the data of the Remote ObjectStore.
   * The return value should be returned to the Remote ObjectStore.
   * @param request - the request information from Remote (JSON Compatible).
   * @returns a Promise containing the response for the Request to send to Remote (JSON Compatible).
   */
  async requestHandler(request: Transferable): Promise<Transferable> {
    this.#checkClosed();
    if (typeof request !== "object") throw new Error("request is not a message from Remote ObjectStore because it is not a object.");
    if (!("type" in request)) throw new Error("request is not a message from Remote ObjectStore because it has no type field.");
    switch (request["type"]) {
      case "close": return this.close(), "";
      case "request": return await this.#requestValueHandler(<ValueRequestDescription>request);
      default: throw new Error("request is not a message from Remote ObjectStore because it has a unknown value in the type field.");
    }
  };

  /**
   * Handles a Value Request.
   * @param request - Description of the Request to Handle.
   * @returns The Response.
   */
  async #requestValueHandler(request: ValueRequestDescription): Promise<ValueResponseDescription> {
    const gcValues = request.gcObjects.map((description) => this.#pregenerateGcValue(description));
    const value = this.#createLocalValue(request);
    // Hold on to the Values, for the duration of the request to ensure they are not garbage collected before they are used.
    gcValues;
    const gcObjects: GcObjectsDescription = [];
    return { type: "response", value: await this.#describePromise(value, gcObjects), gcObjects };
  }

  /**
   * Registers GcObjects th the Cache to be accessed later.
   * Deletes the Id, in deletedRemoteIds set.
   * @param description - description of the Object to Generate.
   * @returns the Object to avoid the object being garbage collected during the Request.
   */
  #pregenerateGcValue(description: GcObjectDescription): Promise<{} | symbol> {
    const id = description.id;
    const stringId = typeof id === "string";
    let oldValue = undefined;
    if (stringId) {
      oldValue = this.#valueFromRemoteStringId.get(id);
    } else {
      const cache = this.#valueFromRemoteNumberId.get(id);
      if (cache !== undefined) {
        oldValue = cache.deref();
      }
      this.#deletedRemoteIds.delete(id);
    }
    const value = this.#createGcValue(description, oldValue);
    if (stringId) {
      this.#valueFromRemoteStringId.set(id, value);
    } else {
      this.#valueFromRemoteNumberId.set(id, new WeakRef(value));
      this.#finalizationReg.register(value, id);
    }
    return value;
  }

  /**
   * Generates the Value for a ValueResponse.
   * @param response - the response for a Value Request.
   * @returns the value or throws if it is an error.
   */
  async #createResponseValue(response: ValueResponseDescription): Promise<unknown> {
    const gcValues = response.gcObjects.map((description) => this.#pregenerateGcValue(description));
    const valueDescription = response.value;
    let value: unknown = undefined;
    if (typeof valueDescription === "object" && valueDescription.type === "error") {
      let error: unknown;
      if (this.#options.remoteError === "remoteObject") {
        error = await this.#createValue(valueDescription.value);
      } else {
        error = createError(valueDescription, await this.#createValue(valueDescription.value));
      }
      // Hold on to the Values, for the duration of the request to ensure they are not garbage collected before they are used.
      gcValues;
      throw error;
    }
    value = this.#createValue(valueDescription);
    // Hold on to the Values, for the duration of the request to ensure they are not garbage collected before they are used.
    gcValues;
    return value;
  }

  /**
   * Resolves a Local Value by following the Path if it exists.
   * @param description - Description of the local Value.
   * @returns the Value.
   */
  async #createLocalValue(description: RemoteDescription): Promise<unknown> {
    const id = description.id;
    const rootDesc = this.#descFromLocalId.get(id);
    if (rootDesc === undefined) throw new Error(`Local Object with id ${id} is unknown.`);
    let value: any = rootDesc.value;
    if (description.path === undefined) return value;
    let parent: any = undefined;
    for (const segment of description.path) {
      switch (segment.type) {
        case "get":
          parent = value;
          value = await value[await this.#createKeyValue(segment.name)];
          break;
        case "set":
          value[await this.#createKeyValue(segment.name)] = await this.#createValue(segment.value);
          parent = undefined;
          value = undefined;
          break;
        case "call":
          value = await value.call(parent, ...await Promise.all(segment.args.map((v) => this.#createValue(v))));
          parent = undefined;
          break;
        case "new":
          parent = undefined;
          value = await new value(...await Promise.all(segment.args.map((v) => this.#createValue(v))));
          break;
      }
    }
    return value;
  }

  /**
   * Creates the Key Value based on the Description.
   * @param description - the Description to the Key.
   * @returns returns a Symbol or String.
   */
  async #createKeyValue(description: KeyDescription): Promise<string | symbol> {
    if (typeof description === "string") return description;
    if (description.type === "remote") return (await this.#createLocalValue(description)) as symbol;
    return (await this.#getRemoteValue(description)) as symbol;
  }

  /**
   * Generated a Value based on its Description.
   * @param description - description of the value to be generated.
   * @returns the value wich should be generated.
   */
  async #createValue(description: ValueDescription): Promise<unknown> {
    switch (typeof description) {
      case "string": return description;
      case "number": return description;
      case "boolean": return description;
      case "object":
        switch (description.type) {
          case "undefined": return undefined;
          case "null": return null;
          case "bigint": return BigInt(description.value);
          case "local":
            return this.#getRemoteValue(description);
          case "remote":
            return this.#createLocalValue(description);
        }
    }
  }

  /**
   * Looks up remote Id in cache.
   * Value must be in Cache because pregenerateGcValue gets called before handling the Request.
   * @param description 
   * @returns 
   */
  async #getRemoteValue(description: LocalGcId): Promise<{} | symbol> {
    const id = description.id;
    const stringId = typeof id === "string";
    if (stringId) {
      const cache = this.#valueFromRemoteStringId.get(id);
      if (cache !== undefined) return cache;
    } else {
      const cache = this.#valueFromRemoteNumberId.get(id);
      if (cache !== undefined) {
        const value = cache.deref();
        if (value !== undefined) return value;
      }
    }
    throw new Error(`Remote Object with id ${id} is unknown.`);
  }

  /**
   * Creates a Value from Remote transmitted via gcObjects.
   * @param description - description of the Value to create.
   * @returns Promise of the Value.
   */
  async #createGcValue(description: GcObjectDescription, oldValue: Promise<symbol | {}> | undefined): Promise<symbol | {}> {
    let old = undefined;
    try {
      old = await oldValue;
    } catch { }
    switch (description.type) {
      case "symbol": return this.#createSymbolValue(description, old);
      case "object": return this.#createObjectValue(description, old);
      case "function": return this.#createFunctionValue(description, old);
    }
  }

  /**
   * Creates a new Symbol wich represents the Symbol from remote.
   * @param description - description of the Symbol.
   * @returns the new Symbol.
   */
  async #createSymbolValue(description: SymbolDescription, old: symbol | {} | undefined): Promise<symbol> {
    if (typeof old === "symbol") return old;
    const symbol = Symbol();
    this.#remoteSymbolIds.set(symbol, description.id);
    return symbol;
  }

  /**
   * Creates a new Remote Object based on a description provided by the remote.
   * Allows the use of getPrototypeOf, has and ownKeys if configured by the options.
   * This allows the proxy to be used in situations like ```key in object```, ```object instanceof class```, ```Object.keys(object)``` or similar.
   * @param desc - description of the remote Object.
   * @returns a Proxy Object representing the remote Object.
   */
  async #createObjectValue(desc: ObjectDescription, old: {} | undefined): Promise<{}> {
    if (old !== undefined) {
      const oldDescription = (this.#getProxyData(old) as RootPathSegment | undefined)?.description as ResolvedObjectDescription | undefined;
      await this.#resolveObjectDescription(desc, oldDescription);
      return old;
    }
    const description = await this.#resolveObjectDescription(desc);
    const data: RootPathSegment = {
      type: "root",
      id: desc.id,
      description,
    };
    return this.#createRemoteProxy(data, {}, {
      getPrototypeOf(_target: unknown): {} | null {
        return description.prototype;
      },
      has(_target: unknown, property: string | symbol): boolean {
        if (description.ownKeys.has(property)) return true;
        if (description.hasKeys.includes(property)) return true;
        if (description.prototype === null) return false;
        return property in description.prototype;
      },
      ownKeys(_target: unknown): (string | symbol)[] {
        return [...description.ownKeys.keys()];
      },
      getOwnPropertyDescriptor(_target: unknown, property: string | symbol): { configurable: true, enumerable: boolean; } | undefined {
        return description.ownKeys.get(property);
      },
    });
  };

  /**
   * Resolves a description an optionally updates a old Description.
   * @param description - the Description to resolve.
   * @param oldDescription - the Old Description to optionally update.
   * @returns resolved description.
   */
  async #resolveObjectDescription(description: ObjectDescription, oldDescription?: ResolvedObjectDescription | undefined): Promise<ResolvedObjectDescription> {
    const ownKeys = await this.#createOwnKeysMap(description.ownKeys);
    const hasKeys = await Promise.all(description.hasKeys.map((v) => this.#createKeyValue(v)));
    const prototype = await this.#createValue(description.prototype) as {} | null;
    if (oldDescription === undefined) return { ownKeys, hasKeys, prototype };
    oldDescription.ownKeys = ownKeys;
    oldDescription.hasKeys = hasKeys;
    oldDescription.prototype = prototype;
    return oldDescription;
  }

  /**
   * Creates a new Remote Object based on a description provided by the remote.
   * Allows the use of getPrototypeOf, has and ownKeys if configured by the options.
   * This allows the proxy to be used in situations like ```key in object```, ```object instanceof class```, ```Object.keys(object)``` or similar.
   * @param desc - description of the remote Object.
   * @returns a Proxy Object representing the remote Object.
   */
  async #createFunctionValue(desc: FunctionDescription, old: {} | undefined): Promise<{}> {
    if (old !== undefined) {
      const oldDescription = (this.#getProxyData(old) as RootPathSegment | undefined)?.description as ResolvedFunctionDescription | undefined;
      await this.#resolveFunctionDescription(desc, oldDescription);
      return old;
    }
    const description = await this.#resolveFunctionDescription(desc);
    const data: RootPathSegment = {
      type: "root",
      id: desc.id,
      description,
    };
    let base = callableDefinition;
    const functionWithPrototype = description.ownKeys.has("prototype");
    if (functionWithPrototype) base = functionDefinition;
    return this.#createRemoteProxy(data, base, {
      getPrototypeOf(_target: unknown): {} | null {
        return description.prototype;
      },
      has(_target: unknown, property: string | symbol): boolean {
        if (description.ownKeys.has(property)) return true;
        if (description.hasKeys.includes(property)) return true;
        if (description.prototype === null) return false;
        return property in description.prototype;
      },
      ownKeys(_target: unknown): (string | symbol)[] {
        return [...description.ownKeys.keys()];
      },
      getOwnPropertyDescriptor(_target: unknown, property: string | symbol): { configurable: boolean, enumerable: boolean; writable?: boolean; } | undefined {
        if (functionWithPrototype && property === "prototype") return { configurable: false, enumerable: false, writable: true };
        return description.ownKeys.get(property);
      },
    });
  };

  /**
   * Resolves a description an optionally updates a old Description.
   * @param description - the Description to resolve.
   * @param oldDescription - the Old Description to optionally update.
   * @returns resolved description.
   */
  async #resolveFunctionDescription(description: FunctionDescription, oldDescription?: ResolvedFunctionDescription | undefined): Promise<ResolvedFunctionDescription> {
    const ownKeys = await this.#createOwnKeysMap(description.ownKeys);
    const hasKeys = await Promise.all(description.hasKeys.map((v) => this.#createKeyValue(v)));
    const prototype = await this.#createValue(description.prototype) as {} | null;
    const functionPrototype = await this.#createValue(description.functionPrototype);
    if (oldDescription === undefined) return { ownKeys, hasKeys, prototype, functionPrototype };
    oldDescription.ownKeys = ownKeys;
    oldDescription.hasKeys = hasKeys;
    oldDescription.prototype = prototype;
    oldDescription.functionPrototype = functionPrototype;
    return oldDescription;
  }

  /**
   * Request a Value from remote.
   * @param remotePath - the description on how to get this data (description of properties and function calls).
   * @returns the value of the requested data.
   */
  async #requestValue(remotePath: RemotePath): Promise<unknown> {
    const request = this.#describeValueRequest(remotePath);
    const response = await this.#requestHandler.request(request) as ValueResponseDescription;
    const value = await this.#createResponseValue(response);
    return value;
  };

  /**
   * Describes all the Values associated with a value request.
   * @param remotePath - The Request to Describe.
   * @returns the Description of the Request.
   */
  #describeValueRequest(remotePath: RemotePath): ValueRequestDescription {
    const gcObjects: GcObjectsDescription = [];
    return { ...this.#describeRemoteValuePath(remotePath, gcObjects), type: "request", gcObjects, };
  }

  /**
   * Awaits a Promise and describes the Result.
   * If the Promise rejects the error is described.
   * @param promise - the Promise to await.
   * @returns the Description of the resolved value or rejected Error.
   */
  async #describePromise(promise: Promise<unknown>, gcObjects: GcObjectsDescription): Promise<ResponseValueDescription> {
    try {
      return this.#describeValue(await promise, gcObjects);
    } catch (error) {
      if (error instanceof Error) {
        const ret: ErrorDescription = { type: "error", value: this.#describeValue(error, gcObjects) };
        if (error.message !== undefined) ret.message = error.message;
        if (error.stack !== undefined) ret.stack = error.stack;
        if (error.name !== undefined) ret.name = error.name;
        return ret;
      }
      return { type: "error", value: this.#describeValue(error, gcObjects) };
    }
  };

  /**
   * Describes a RemoteValuePath.
   * @param remotePath - The Remote Value Path.
   * @param gcObjects - Objects to send along.
   * @returns description of the path.
   */
  #describeRemoteValuePath(remotePath: RemotePath, gcObjects: GcObjectsDescription): RemoteGcId {
    if (remotePath.type === "root") return { type: "remote", id: remotePath.id };
    const path: ExtendingRemotePath[] = [];
    while (remotePath.type !== "root") {
      path.push(remotePath);
      remotePath = remotePath.parent;
    }
    return {
      type: "remote",
      id: remotePath.id,
      path: path.reverse().map((pathSegment) => this.#describePathSegment(pathSegment, gcObjects))
    };
  }

  /**
   * Describes a single segment of a RemoteValuePath.
   * @param pathSegment - the Segment to Describe.
   * @param gcObjects - the Objects to send along.
   * @returns description of the Segment.
   */
  #describePathSegment(pathSegment: ExtendingRemotePath, gcObjects: GcObjectsDescription): ValueSegment {
    switch (pathSegment.type) {
      case "get": return { type: "get", name: this.#describeKey(pathSegment.name, gcObjects) };
      case "new": return { type: "new", args: this.#describeValues(pathSegment.args, gcObjects) };
      case "call": return { type: "call", args: this.#describeValues(pathSegment.args, gcObjects) };
      case "set": return { type: "set", name: this.#describeKey(pathSegment.name, gcObjects), value: this.#describeValue(pathSegment.value, gcObjects) };
    }
  }

  /**
   * Describes a Key of an Object.
   * @param key - the Key to describe.
   * @param gcObjects - the Objects to send along.
   * @returns the Description of the Key.
   */
  #describeKey(key: Key, gcObjects: GcObjectsDescription): KeyDescription {
    if (typeof key === "string") return key;
    return this.#describeSymbol(key, gcObjects);
  }

  /**
   * Describes multiple Values (Primitive or objects).
   * @param values - the Values to Describe.
   * @param gcObjects - the Objects to send along.
   * @returns descriptions of the Values.
   */
  #describeValues(values: unknown[], gcObjects: GcObjectsDescription): ValueDescription[] {
    return values.map((v) => this.#describeValue(v, gcObjects));
  }

  /**
   * Describes a single Value (Primitive or Object).
   * @param value - the value to describe.
   * @param gcObjects - the Objects to send along.
   * @returns description of the value;
   */
  #describeValue(value: unknown, gcObjects: GcObjectsDescription): ValueDescription {
    switch (typeof value) {
      case "string": return value;
      case "number": return value;
      case "boolean": return value;
      case "bigint": return { type: "bigint", value: value.toString() };
      case "undefined": return undefinedDescription;
      case "symbol":
        return this.#describeSymbol(value, gcObjects);
      case "object":
        return this.#describeObject(value, gcObjects);
      case "function":
        return this.#describeFunction(value, gcObjects);
    }
  }

  /**
   * Describes a Symbol (Local or Remote).
   * @param symbol - the Symbol to describe.
   * @param gcObjects - the Objects to send along.
   * @returns description of the Symbol.
   */
  #describeSymbol(symbol: symbol, gcObjects: GcObjectsDescription): LocalizedGcId {
    const id = this.#remoteSymbolIds.get(symbol);
    if (id !== undefined) return { type: "remote", id };
    return { type: "local", id: this.#describeLocalSymbol(symbol, gcObjects) };
  }

  /**
   * Describes an object (Local or Remote).
   * @param object - the Object to Describe.
   * @param gcObjects - the Objects to send along.
   * @returns description of the Object.
   */
  #describeObject(object: {} | null, gcObjects: GcObjectsDescription): LocalizedGcId | NullDescription {
    if (object === null) return nullDescription;
    const proxyData = this.#getProxyData(object);
    if (proxyData !== undefined) return this.#describeRemoteValuePath(proxyData, gcObjects);
    return { type: "local", id: this.#describeLocalObject(object, gcObjects) };
  }

  /**
   * Describes a Function (Local or Remote).
   * @param fn - the Function to Describe.
   * @param gcObjects - the Objects to send along.
   * @returns description of the Function.
   */
  #describeFunction(fn: Function, gcObjects: GcObjectsDescription): ValueDescription {
    const proxyData = this.#getProxyData(fn);
    if (proxyData !== undefined) return this.#describeRemoteValuePath(proxyData, gcObjects);
    return { type: "local", id: this.#describeLocalFunction(fn, gcObjects) };
  }

  /**
   * Describes a local Object and adds it to the gcObjects.
   * @param localObject - the Object to describe.
   * @param gcObjects - the Objects to send along.
   * @returns description of the object.
   */
  #describeLocalObject(localObject: {}, gcObjects: GcObjectsDescription): GcId {
    const id = this.#getLocalIdFromValue(localObject);
    const ownKeys: OwnKeyDescription[] = Object.entries(Object.getOwnPropertyDescriptors(localObject))
      .map(([key, value]) => ({ key: this.#describeKey(key, gcObjects), enumerable: value.enumerable === true }));;
    let hasKeys: KeyDescription[] = [];
    if (this.#options.remoteObjectPrototype === "keysOnly") hasKeys = getAllKeys(localObject).map((key) => this.#describeKey(key, gcObjects));
    let prototype: LocalizedGcId | NullDescription = nullDescription;
    if (this.#options.remoteObjectPrototype === "full") prototype = this.#describeObject(Reflect.getPrototypeOf(localObject), gcObjects);
    gcObjects.push({ type: "object", id, ownKeys, hasKeys, prototype });
    return id;
  }

  /**
   * Describes a local Function and adds it to the gcObjects.
   * @param localFunction - the Function to describe.
   * @param gcObjects - the Objects to send along.
   * @returns description of the Function.
   */
  #describeLocalFunction(localFunction: Function, gcObjects: GcObjectsDescription): GcId {
    const id = this.#getLocalIdFromValue(localFunction);
    const ownKeys: OwnKeyDescription[] = Object.entries(Object.getOwnPropertyDescriptors(localFunction))
      .map(([key, value]) => ({ key: this.#describeKey(key, gcObjects), enumerable: value.enumerable === true }));;
    let hasKeys: KeyDescription[] = [];
    if (this.#options.remoteObjectPrototype === "keysOnly") hasKeys = getAllKeys(localFunction).map((key) => this.#describeKey(key, gcObjects));
    let prototype: LocalizedGcId | NullDescription = nullDescription;
    if (this.#options.remoteObjectPrototype === "full") prototype = this.#describeObject(Reflect.getPrototypeOf(localFunction), gcObjects);
    const functionPrototype: ValueDescription = this.#describeValue(localFunction.prototype, gcObjects);
    gcObjects.push({ type: "function", id, ownKeys, hasKeys, prototype, functionPrototype });
    return id;
  };

  /**
   * Describes a local Symbol and adds it to the gcObjects.
   * @param symbol - the symbol to describe.
   * @param gcObjects - the Objects to send along.
   * @returns description of the Symbol.
   */
  #describeLocalSymbol(symbol: symbol, gcObjects: GcObjectsDescription): GcId {
    const id = this.#getLocalIdFromValue(symbol);
    gcObjects.push({ type: "symbol", id });
    return id;
  }

  /**
   * Get the ID of an Local Value.
   * Id the Local object is not in the local Cache (localGcObjectIds), create a new id.
   * @param value - the value for wich to retrieve the id.
   * @returns the id to be used together with this value.
   */
  #getLocalIdFromValue(value: symbol | object): GcId {
    let description = this.#descFromLocalValue.get(value);
    if (description !== undefined) {
      description.time = performance.now();
      return description.id;
    }
    const id = this.#nextId();
    const time = performance.now();
    this.#newLocalIds.set(id, time);
    description = { id, time, value };
    this.#descFromLocalValue.set(value, description);
    this.#descFromLocalId.set(id, description);
    return description.id;
  }

  /**
 * Generates a new Proxy Object without any description.
 * Does not Support getPrototypeOf, has and ownKeys.
 * If these need to be used the Proxy needs to be awaited first to request this information from remote.
 * It will create new Proxies for property accesses, function calls, constructions and set calls.
 * A Request to the remote is only trigged if a value is awaited (a call to then) or the set Method is called.
 * Even Function calls are only trigged when their result is awaited.
 * @param parent - Description of the Path as an linked list (parent field).
 * @param base - target object to be used with the Proxy (default = new Function()).
 * @param resolveAsPromise - Defines if then has an effect on the Proxy. Will prevent endless then loop (default = true).
 * @param functionPrototype - If not equal to undefined, this value will be returned for the prototype field (default = undefined).
 * @param additionalHandlers - extra handlers to provide extra functionality to the Proxy. 
 * @returns a Proxy Object representing the remote Object.
 */
  #createRemoteProxy(parent: ExtendableRemotePath, base: {} = functionDefinition, additionalHandlers: ProxyHandler<{}> = {}): {} {
    const handler: ProxyHandler<{}> = {
      get: (_target: unknown, name: string | symbol, _receiver: unknown): unknown => {
        switch (name) {
          case "then":
            if (parent.type === "root") return undefined;
            return (onfulfilled: () => void, onrejected: () => void): void => {
              this.#requestValue(parent).then(onfulfilled, onrejected);
            };
          case "set":
            return async (value: unknown): Promise<void> => {
              if (parent.type !== "get") throw new TypeError("Cannot write to a RemoteObject or Return Value. Only properties can be set.");
              await this.#requestValue({ type: "set", value, name: parent.name, parent: parent.parent });
            };
          case "prototype":
            if (parent.type !== "root" || parent.description === undefined || !("functionPrototype" in parent.description)) break;
            return parent.description.functionPrototype;
          case "toString":
            if (this.#options.noToString) break;
            return Object.prototype.toString;
          case Symbol.toStringTag:
            if (this.#options.noToString) break;
            return "RemoteObject";
          case Symbol.toPrimitive:
            if (this.#options.noToString) break;
            return undefined;
          case Symbol.hasInstance:
            return undefined;
          case this.#symbolProxyData:
            return parent;
          case isProxySymbol:
            return true;
        }
        return this.#createRemoteProxy({ type: "get", name, parent });
      },
      apply: (_target: unknown, _thisArg: unknown, args: unknown[]): {} => {
        return this.#createRemoteProxy({ type: "call", args, parent });
      },
      construct: (_target: unknown, args: unknown[], _newTarget: unknown): {} => {
        return this.#createRemoteProxy({ type: "new", args, parent });
      },
      ...additionalHandlers
    };
    Object.setPrototypeOf(handler, UnsupportedHandlers);
    return new Proxy(base, handler);
  }

  /**
   * Generates a Map describing all own keys.
   * @param ownKeys - an Array of all own keys.
   * @returns a Map containing this description based on key.
   */
  async #createOwnKeysMap(ownKeys: OwnKeyDescription[]): Promise<Map<string | symbol, { configurable: true, enumerable: boolean; }>> {
    return new Map(await Promise.all(ownKeys.map(async (v) => [await this.#createKeyValue(v.key), { configurable: true, enumerable: v.enumerable }] as const)));
  };

  /**
   * Returns the internal data of the Proxy if value is a Proxy.
   * @param value - any value which is maybe an Proxy.
   * @returns the internal Data of the Proxy or undefined if value is not a Proxy.
   */
  #getProxyData(value: Function | object): ExtendableRemotePath | undefined {
    return (<MayHaveSymbol<ExtendableRemotePath>>value)[this.#symbolProxyData];
  }

  /**
   * Called whenever a remote object was garbage collected.
   * Will remove the Objects form cache and remember the id to inform remote later.
   * @param id - the id of the object wich was garbage collected.
   */
  #cleanupObject(id: number): void {
    this.#deletedRemoteIds.add(id);
    this.#valueFromRemoteNumberId.delete(id);
  }

  /**
   * Generates a new number as RemoteId to uniquely identify an object.
   * @returns a number wich is not used by any other objects.
   */
  #nextId(): number {
    do {
      this.#lastId = this.#lastId + 1;
      if (this.#lastId >= Number.MAX_SAFE_INTEGER) {
        this.#lastId = Number.MIN_SAFE_INTEGER;
      }
      if (!this.#descFromLocalId.has(this.#lastId)) {
        return this.#lastId;
      }
    } while (true);
  }

  /**
   * throws an Error if the Connection is already closed.
   */
  #checkClosed() {
    if (this.#closed) throw new Error("Connection is already closed.");
  }
}

/**
 * Symbol for marking RemoteObjects and Proxies for identifying them.
 */
const isProxySymbol: unique symbol = Symbol();

/**
 * Returns true if it is given a RemoteObject Proxy.
 * @param object - Any Value to test if it represents a proxy.
 * @returns boolean indicating if object is a RemoteObject Proxy.
 * @public
 */
export function isProxy(object: unknown): boolean {
  if (typeof object !== "function" && typeof object !== "object") return false;
  if (object === null) return false;
  return !!(object as MayHaveSymbol<boolean>)[isProxySymbol];
};

/**
 * Creates a unique array of Keys of the Object and its Prototype chain.
 * @param object - Object to list all the keys of (also of Prototype chain).
 * @returns An array of keys.
 */
function getAllKeys(object: {}): (string | symbol)[] {
  const ret: Set<string | symbol> = new Set();
  let o: {} | null = object;
  while (o !== null) {
    for (const key of Reflect.ownKeys(o)) {
      ret.add(key);
    }
    o = Reflect.getPrototypeOf(o);
  }
  return [...ret.values()];
}

/**
 * Creates an Error Class most closely representing the remote Error.
 * @param description - Description of the Error to be created.
 * @param cause - RemoteObject of the remote Error.
 * @returns an Error Object.
 */
function createError(description: ErrorDescription, cause: unknown): unknown {
  if (description.message === undefined && description.stack === undefined && description.name === undefined) return cause;
  const error = new Error(description.message, { cause });
  if (description.name !== undefined) {
    if (error.stack !== undefined && error.stack.startsWith(error.name)) error.stack = description.name + error.stack.slice(error.name.length);
    error.name = description.name;
  }
  if (description.stack !== undefined) {
    if (error.stack === undefined) {
      error.stack = "Remote Stacktrace:\n" + description.stack;
    } else {
      error.stack += "\n\nRemote Stacktrace:\n" + description.stack;
    }
  }
  (<MayHaveSymbol<() => string>><unknown>error)[Symbol.toStringTag] = () => "Error";
  Object.setPrototypeOf(error, Object.getPrototypeOf(cause));
  return error;
}

/**
 * Object representing undefined.
 */
const undefinedDescription: UndefinedDescription = { type: "undefined" };

/**
 * Object representing null.
 */
const nullDescription: NullDescription = { type: "null" };

/**
 * A callable used for Proxies.
 */
/* istanbul ignore next */
const callableDefinition: Function = () => { };

/**
 * A Function used for Proxies.
 */
/* istanbul ignore next */
const functionDefinition: Function = function () { };

/**
 * Definition of all unsupported handlers.
 */
const UnsupportedHandlers: ProxyHandler<{}> = {
  getPrototypeOf(_target: unknown): never {
    throw new TypeError("getPrototypeOf is not Supported by RemoteObject Proxy. Await the RemoteObject to be able to query metadata.");
  },
  has(_target: unknown, _property: string | symbol): never {
    throw new TypeError("has is not Supported by RemoteObject Proxy. Await the RemoteObject to be able to query metadata.");
  },
  ownKeys(_target: unknown): never {
    throw new TypeError("ownKeys is not Supported by RemoteObject Proxy. Await the RemoteObject to be able to query metadata.");
  },
  getOwnPropertyDescriptor(_target: unknown, _property: string | symbol): never {
    throw new TypeError("getOwnPropertyDescriptor is not Supported by RemoteObject Proxy. Await the RemoteObject to be able to query metadata.");
  },
  defineProperty(_target: unknown, _property: string | symbol, _attributes: PropertyDescriptor): false {
    return false;
  },
  deleteProperty(_target: unknown, _property: string | symbol): false {
    return false;
  },
  isExtensible(_target: unknown): never {
    throw new TypeError("isExtensible is not Supported by RemoteObject");
  },
  preventExtensions(_target: unknown): false {
    return false;
  },
  set(_target: unknown, _property: string | symbol, _newValue: unknown, _receiver: unknown): false {
    return false;
  },
  setPrototypeOf(_target: unknown, _prototype: object | null): false {
    return false;
  },
};